(define nil '())

(define (not x)
  (if x
    false
    true))

(define (list . objs)
  objs)

(define (id obj)
  obj)

(define (flip f)
  (lambda (arg1 arg2)
    (f arg2 arg1)))

(define (curry f arg1)
  (lambda (arg)
    (apply f arg1 arg)))

(define (compose f g)
  (lambda (arg)
    (f (apply g arg))))

(define zero?
  (curry = 0))

(define positive?
  (curry < 0))

(define negative?
  (curry > 0))

(define (odd? num)
  (= (% num 2) 1))

(define even?
  (compose not odd?))

(define fst car)
(define (snd li) (car (cdr li)))

(define (map f li)
  (foldr
    (lambda (x y) (cons (f x) y))
    '()
    li))

(define (foldr f end li)
  (if (null? li)
    end
    (f (car li) (foldr f end (cdr li)))))

(define ($$let-lambdas li body)
    (if (eqv? li '())
        body
        (list 'lambda (list (car li))
          ($$let-lambdas (cdr li) body))))

(define ($$let-arguments lbds args)
    (if (eqv? args '())
        lbds
        (list 'apply
          ($$let-arguments lbds (cdr args))
          (list 'list (car args)))))

(define (let 'pairs 'body)
    (eval
      ($$let-arguments
        ($$let-lambdas (map fst pairs) body)
        (map snd (reverse pairs)))
      '()))
